[
  {
    "id": "q1-1",
    "number": "1-1",
    "module": "Software Architecture 핵심",
    "subModule": "I/F 기반 Data 동기화",
    "title": "I/F 기반의 Data 동기화 문제",
    "difficulty": "중급",
    "points": 4,
    "question": "대내 시스템 간 실시간 데이터 동기화를 위해 EAI를 통한 트랜잭션 처리 방식을 설계 중이다. 아래 설명 중 올바르지 않은 것은?\n\n① EAI에서 트랜잭션 실패 시 보상 트랜잭션(Compensating Transaction)을 통해 데이터 정합성을 유지할 수 있다.\n② 실시간 동기화에서는 2PC(Two-Phase Commit)보다 SAGA 패턴이 더 적합하다.\n③ EAI 허브를 통한 동기화는 각 시스템이 직접 연결되는 방식보다 결합도를 낮춘다.\n④ 트랜잭션 ID를 통해 분산된 시스템 간의 데이터 일관성을 추적할 수 있다.\n⑤ EAI에서 동기 방식 호출 시 타임아웃이 발생하면 자동으로 비동기 방식으로 전환된다.",
    "answer": "⑤",
    "explanation": "EAI에서 타임아웃 발생 시 자동으로 호출 방식이 변경되지 않으며, 이는 설계 시점에서 결정되어야 한다.",
    "keywords": [
      "EAI",
      "Data 동기화",
      "트랜잭션",
      "SAGA",
      "2PC"
    ]
  },
  {
    "id": "q1-2",
    "number": "1-2",
    "module": "Software Architecture 설계/구축",
    "subModule": "Reactive Programming",
    "title": "Reactive Programming 개념 이해",
    "difficulty": "하급",
    "points": 3,
    "question": "Spring WebFlux를 사용한 비동기 처리에서 다음 중 올바른 설명은?\n\n① Flux는 0-1개의 데이터를 처리하고, Mono는 0-N개의 데이터를 처리한다.\n② 비동기 처리에서는 스레드 블로킹이 발생하지 않으므로 더 많은 동시 요청을 처리할 수 있다.\n③ WebFlux는 내부적으로 Servlet Container를 사용한다.\n④ 비동기 처리 시 예외 처리는 try-catch 블록으로만 가능하다.\n⑤ CompletableFuture와 Reactor는 동일한 개념이다.",
    "answer": "②",
    "explanation": "비동기 논블로킹 방식은 스레드가 블로킹되지 않아 적은 수의 스레드로 더 많은 요청을 처리할 수 있다. Flux는 0-N개, Mono는 0-1개 데이터를 처리한다.",
    "keywords": [
      "Spring WebFlux",
      "Reactive",
      "Flux",
      "Mono",
      "비동기"
    ]
  },
  {
    "id": "q1-3",
    "number": "1-3",
    "module": "Software Architecture 설계/구축",
    "subModule": "MSA",
    "title": "MSA Service Mesh 개념",
    "difficulty": "중급",
    "points": 4,
    "question": "Istio를 활용한 Service Mesh 환경에서 다음 중 잘못된 설명은?\n\n① Envoy Proxy는 각 서비스의 사이드카로 배포되어 네트워크 트래픽을 제어한다.\n② Istio-proxy를 통해 서비스 간 mTLS 암호화가 자동으로 적용된다.\n③ Circuit Breaker 기능을 통해 장애 전파를 방지할 수 있다.\n④ Service Mesh를 적용하면 기존 애플리케이션 코드를 대폭 수정해야 한다.\n⑤ 트래픽 라우팅 규칙을 통해 카나리 배포가 가능하다.",
    "answer": "④",
    "explanation": "Service Mesh는 애플리케이션 코드 수정 없이 인프라 레벨에서 서비스 간 통신을 제어하는 것이 핵심 장점이다.",
    "keywords": [
      "Istio",
      "Service Mesh",
      "Envoy",
      "mTLS",
      "Circuit Breaker"
    ]
  },
  {
    "id": "q1-4",
    "number": "1-4",
    "module": "Software Architecture 설계/구축",
    "subModule": "Framework 적용",
    "title": "WAS 성능 개선 - DBCP 설정",
    "difficulty": "상급",
    "points": 4,
    "question": "Tomcat에서 DBCP 설정을 통한 성능 최적화 시 다음 중 잘못된 설정은?\n\n<Resource name=\"jdbc/myDB\"\n    type=\"javax.sql.DataSource\"\n    driverClassName=\"oracle.jdbc.driver.OracleDriver\"\n    url=\"jdbc:oracle:thin:@localhost:1521:XE\"\n    username=\"user\" password=\"pass\"\n    maxTotal=\"50\"\n    maxIdle=\"30\"\n    minIdle=\"10\"\n    initialSize=\"5\"\n    validationQuery=\"SELECT 1 FROM DUAL\"\n    testOnBorrow=\"true\"\n    testWhileIdle=\"false\"\n    timeBetweenEvictionRunsMillis=\"30000\"\n    minEvictableIdleTimeMillis=\"60000\"\n/>\n\n① validationQuery를 설정하여 연결 유효성을 검증하고 있다.\n② testWhileIdle을 false로 설정하여 유휴 연결 검증을 비활성화했다.\n③ maxTotal이 maxIdle보다 큰 값으로 설정되어 있다.\n④ minEvictableIdleTimeMillis가 timeBetweenEvictionRunsMillis보다 크게 설정되어 있다.\n⑤ initialSize가 minIdle보다 작게 설정되어 있다.",
    "answer": "②",
    "explanation": "testWhileIdle을 false로 설정하면 유휴 연결 검증이 비활성화되어 끊어진 연결을 사용할 위험이 있다. true로 설정해야 한다.",
    "keywords": [
      "DBCP",
      "Tomcat",
      "Connection Pool",
      "Performance"
    ]
  },
  {
    "id": "q1-5",
    "number": "1-5",
    "module": "Software Architecture 핵심",
    "subModule": "JVM 구조 및 동작 특성",
    "title": "JVM Memory 튜닝",
    "difficulty": "상급",
    "points": 4,
    "question": "Kubernetes 환경에서 Java 애플리케이션의 메모리 설정에 대한 설명 중 올바른 것은?\n\nresources:\n  limits:\n    memory: \"2Gi\"\n  requests:\n    memory: \"2Gi\"\nenv:\n- name: JAVA_OPTS\n  value: \"-XX:MaxRAMPercentage=75.0 -XX:InitialRAMPercentage=50.0\"\n\n① MaxRAMPercentage는 컨테이너 메모리 한계의 75%를 힙 메모리로 할당한다.\n② InitialRAMPercentage는 애플리케이션 시작 시 힙 메모리 할당량을 결정한다.\n③ 컨테이너 메모리가 2GB이므로 힙 메모리는 정확히 1.5GB가 할당된다.\n④ Non-heap 메모리는 별도로 고려할 필요가 없다.\n⑤ -Xms와 -Xmx 옵션이 더 정확한 메모리 제어를 제공한다.",
    "answer": "①",
    "explanation": "MaxRAMPercentage는 컨테이너 메모리 한계 대비 힙 메모리 비율을 설정한다. Non-heap 메모리도 함께 고려해야 하므로 75% 설정이 적절하다.",
    "keywords": [
      "JVM",
      "Kubernetes",
      "Memory",
      "Container",
      "Heap"
    ]
  },
  {
    "id": "q1-6",
    "number": "1-6",
    "module": "Software Architecture 설계/구축",
    "subModule": "Frontend",
    "title": "Frontend Browser 객체 Scope",
    "difficulty": "하급",
    "points": 3,
    "question": "다음 JavaScript 코드의 실행 결과로 올바른 것은?\n\nvar x = 1;\nfunction outer() {\n    var x = 2;\n    function inner() {\n        console.log(x);\n        var x = 3;\n        console.log(x);\n    }\n    inner();\n    console.log(x);\n}\nouter();\nconsole.log(x);\n\n① 2, 3, 2, 1\n② undefined, 3, 2, 1\n③ 2, 3, 3, 1\n④ undefined, 3, 3, 1\n⑤ ReferenceError 발생",
    "answer": "②",
    "explanation": "호이스팅으로 인해 inner 함수 내의 var x 선언이 상단으로 올라가지만 할당은 나중에 되므로 첫 번째 console.log는 undefined를 출력한다.",
    "keywords": [
      "JavaScript",
      "Scope",
      "Hoisting",
      "Closure"
    ]
  },
  {
    "id": "q1-7",
    "number": "1-7",
    "module": "Software Architecture 핵심",
    "subModule": "Container Platform",
    "title": "Kubernetes Pod QoS 개념",
    "difficulty": "하급",
    "points": 3,
    "question": "Kubernetes에서 Pod의 QoS 클래스에 대한 설명 중 옳은 것은?\n\n① Guaranteed 클래스는 requests와 limits가 동일하지 않아도 된다.\n② Burstable 클래스는 requests만 설정되고 limits는 설정되지 않은 경우다.\n③ BestEffort 클래스는 requests와 limits가 모두 설정되지 않은 경우다.\n④ QoS 클래스는 스케줄링에만 영향을 미치고 리소스 회수에는 영향을 미치지 않는다.\n⑤ 모든 컨테이너는 동일한 QoS 클래스를 가져야 한다.",
    "answer": "③",
    "explanation": "BestEffort 클래스는 CPU/메모리에 대한 requests와 limits가 모두 설정되지 않은 경우에 해당한다.",
    "keywords": [
      "Kubernetes",
      "QoS",
      "Pod",
      "Resources"
    ]
  },
  {
    "id": "q1-8",
    "number": "1-8",
    "module": "Software Architecture 설계/구축",
    "subModule": "Spring Cloud",
    "title": "Spring Cloud Config 개념",
    "difficulty": "하급",
    "points": 3,
    "question": "Spring Cloud Config Server에 대한 설명 중 잘못된 것은?\n\n① Git Repository를 백엔드 저장소로 사용할 수 있다.\n② 설정 변경 시 애플리케이션을 재시작하지 않고 @RefreshScope를 통해 반영할 수 있다.\n③ 암호화된 속성 값을 {cipher}로 표시하여 저장할 수 있다.\n④ Config Client는 부팅 시점에만 설정을 가져올 수 있다.\n⑤ 환경별(dev, prod) 설정 파일을 분리하여 관리할 수 있다.",
    "answer": "④",
    "explanation": "Config Client는 부팅 시점뿐만 아니라 /actuator/refresh 엔드포인트를 통해 런타임에도 설정을 갱신할 수 있다.",
    "keywords": [
      "Spring Cloud",
      "Config Server",
      "Microservices"
    ]
  },
  {
    "id": "q1-9",
    "number": "1-9",
    "module": "Software Architecture 핵심",
    "subModule": "기반 솔루션",
    "title": "CDN 기능과 활용",
    "difficulty": "하급",
    "points": 3,
    "question": "CDN(Content Delivery Network) 활용에 대한 설명 중 올바르지 않은 것은?\n\n① 정적 콘텐츠 캐싱을 통해 오리진 서버의 부하를 줄일 수 있다.\n② 사용자와 지리적으로 가까운 엣지 서버에서 콘텐츠를 제공한다.\n③ 동적 콘텐츠는 CDN을 통해 캐싱할 수 없다.\n④ Cache-Control 헤더를 통해 캐시 정책을 제어할 수 있다.\n⑤ DDoS 공격 완화 기능을 제공할 수 있다.",
    "answer": "③",
    "explanation": "최신 CDN은 동적 콘텐츠에 대해서도 엣지 컴퓨팅, API 캐싱 등을 통해 성능 향상을 제공할 수 있다.",
    "keywords": [
      "CDN",
      "Cache",
      "Edge Server",
      "Performance"
    ]
  },
  {
    "id": "q1-10",
    "number": "1-10",
    "module": "Software Architecture 핵심",
    "subModule": "Network Protocol",
    "title": "HTTP/2 Protocol 심화",
    "difficulty": "중급",
    "points": 4,
    "question": "HTTP/2 프로토콜의 특징에 대한 설명 중 잘못된 것은?\n\n① 멀티플렉싱을 통해 하나의 커넥션에서 여러 요청을 동시에 처리할 수 있다.\n② 서버 푸시 기능을 통해 클라이언트 요청 전에 리소스를 전송할 수 있다.\n③ HPACK 압축을 통해 헤더 크기를 줄인다.\n④ 텍스트 기반 프로토콜이므로 디버깅이 용이하다.\n⑤ Stream 우선순위를 설정하여 중요한 리소스를 먼저 전송할 수 있다.",
    "answer": "④",
    "explanation": "HTTP/2는 바이너리 프로토콜이므로 HTTP/1.1과 달리 텍스트 기반이 아니다. 이로 인해 파싱 효율성은 높지만 디버깅은 더 어려워진다.",
    "keywords": [
      "HTTP/2",
      "Multiplexing",
      "HPACK",
      "Binary Protocol"
    ]
  },
  {
    "id": "q1-11",
    "number": "1-11",
    "module": "Software Architecture 설계/구축",
    "subModule": "분산 시스템 패턴",
    "title": "SAGA 패턴 개념",
    "difficulty": "중급",
    "points": 4,
    "question": "MSA 환경에서 분산 트랜잭션 처리를 위한 SAGA 패턴에 대한 설명으로 적절하지 않은 것은?\n\n① Choreography 방식에서는 각 서비스가 자율적으로 다음 단계를 결정한다.\n② Orchestration 방식에서는 중앙 조정자가 트랜잭션 흐름을 제어한다.\n③ 보상 트랜잭션을 통해 실패한 단계를 롤백한다.\n④ ACID 특성을 완전히 보장한다.\n⑤ 이벤트 기반 아키텍처와 잘 결합된다.",
    "answer": "④",
    "explanation": "SAGA 패턴은 BASE(Basically Available, Soft state, Eventual consistency) 특성을 따르며, ACID의 격리성과 일관성을 완전히 보장하지 않는다.",
    "keywords": [
      "SAGA",
      "분산 트랜잭션",
      "MSA",
      "Choreography",
      "Orchestration"
    ]
  },
  {
    "id": "q1-12",
    "number": "1-12",
    "module": "Software Architecture 핵심",
    "subModule": "Security",
    "title": "JWT 보안 고려사항",
    "difficulty": "하급",
    "points": 3,
    "question": "JWT(JSON Web Token) 사용 시 보안 고려사항으로 올바르지 않은 것은?\n\n① JWT는 서명되어 있어 위변조가 불가능하므로 민감한 정보를 포함해도 안전하다.\n② Refresh Token을 별도로 관리하여 Access Token의 유효기간을 짧게 가져간다.\n③ 서버 측에서 토큰 무효화 목록(blacklist)을 관리할 수 있다.\n④ HTTPS를 사용하여 토큰 전송 중 탈취를 방지한다.\n⑤ 토큰에는 사용자 식별 정보만 포함하고 권한 정보는 서버에서 조회한다.",
    "answer": "①",
    "explanation": "JWT는 서명으로 위변조는 방지되지만 Base64 인코딩된 페이로드는 쉽게 디코딩 가능하므로 민감한 정보를 포함해서는 안 된다.",
    "keywords": [
      "JWT",
      "Security",
      "Token",
      "Authentication"
    ]
  },
  {
    "id": "q2-1",
    "number": "2-1",
    "module": "Software Architecture 핵심",
    "subModule": "JVM 구조 및 동작 특성",
    "title": "JVM 모니터링 및 GC 분석",
    "difficulty": "중급",
    "points": 4,
    "question": "다음은 운영 중인 Spring Boot 애플리케이션의 JVM 모니터링 결과이다. jstat -gc 명령어 결과를 분석하여 현재 상황에 대한 설명 중 옳지 않은 것을 고르시오.\n\n$ jstat -gc 25847 5s\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   \n17472.0 17472.0  0.0  16234.1  139648.0  139580.2  349568.0   342156.8  21248.0 20074.3 2560.0 2361.3   1847   12.456    23   8.923   21.379\n17472.0 17472.0  0.0  16845.2  139648.0   5234.1   349568.0   348901.2  21248.0 20134.1 2560.0 2387.1   1851   12.478    24   9.456   21.934\n17472.0 17472.0  0.0  17234.5  139648.0   45123.8  349568.0   348901.2  21248.0 20198.7 2560.0 2401.9   1855   12.501    24   9.456   21.957\n\n① Young Generation에서 Minor GC가 정상적으로 동작하고 있으며, Eden 영역이 가득 찰 때마다 GC가 발생하고 있다.\n② Old Generation 사용률이 약 99%에 달하여 곧 Full GC가 빈번하게 발생할 위험이 있다.\n③ Survivor 영역 중 S1이 사용되고 있어 최근 Minor GC에서 S0에서 S1으로 객체가 이동했음을 알 수 있다.\n④ 15초 동안 Minor GC가 8회 발생하여 GC 발생 빈도가 매우 높은 상태이다.\n⑤ Metaspace 사용률이 약 94%로 높아 Class 로딩 관련 메모리 부족이 우려된다.",
    "answer": "④",
    "explanation": "15초 동안 YGC가 1847→1855로 8회 증가했으나, 이는 정상적인 수준이다. 보통 1초에 1-2회 정도의 Minor GC는 일반적이며, Old 영역이 거의 가득 찬 것이 더 심각한 문제이다.",
    "keywords": [
      "JVM",
      "GC",
      "jstat",
      "Monitoring"
    ]
  },
  {
    "id": "q2-2",
    "number": "2-2",
    "module": "Software Architecture 핵심",
    "subModule": "JVM 구조 및 동작 특성",
    "title": "Kubernetes 환경 JVM 설정",
    "difficulty": "상급",
    "points": 4,
    "question": "다음은 Kubernetes 환경에서 Spring Boot 애플리케이션의 JVM 설정에 대한 설명이다. 컨테이너 리소스 제한과 JVM 힙 메모리 설정의 조합 중 문제가 될 수 있는 것을 고르시오.\n\n# Pod 리소스 설정\nresources:\n  limits:\n    memory: \"2Gi\"\n    cpu: \"1\"\n  requests:\n    memory: \"1Gi\"  \n    cpu: \"0.5\"\n\n① JVM 옵션: -Xms1g -Xmx1.5g\n② JVM 옵션: -XX:MaxRAMPercentage=75.0 -XX:InitialRAMPercentage=50.0\n③ JVM 옵션: -Xms512m -Xmx1792m\n④ JVM 옵션: -XX:MaxRAMPercentage=95.0 -XX:MinRAMPercentage=80.0\n⑤ JVM 옵션: -Xms1g -Xmx1g -XX:+UseContainerSupport",
    "answer": "④",
    "explanation": "MaxRAMPercentage=95.0은 컨테이너 메모리 2GB의 95%(약 1.9GB)를 힙으로 사용하려 하지만, JVM은 힙 외에도 Metaspace, Direct Memory, Stack 등을 사용하므로 OOMKilled 위험이 있다.",
    "keywords": [
      "JVM",
      "Kubernetes",
      "Container",
      "Memory"
    ]
  },
  {
    "id": "q2-3",
    "number": "2-3",
    "module": "Software Architecture 핵심",
    "subModule": "JVM 구조 및 동작 특성",
    "title": "OutOfMemoryError 분석",
    "difficulty": "하급",
    "points": 3,
    "question": "웹 애플리케이션에서 OutOfMemoryError가 발생한 후 Heap Dump를 분석한 결과 다음과 같은 정보를 얻었다. 이 상황에서 메모리 누수의 가장 가능성이 높은 원인을 고르시오.\n\n[Eclipse MAT Dominator Tree 분석 결과]\nClass Name                           Objects    Retained Heap\njava.util.concurrent.ConcurrentHashMap    1       156,789,456 bytes\n├── java.util.concurrent.ConcurrentHashMap$Node[]  1  145,234,567 bytes\n    ├── com.example.UserSession           45,678    98,765,432 bytes\n    ├── java.sql.PreparedStatement        45,678    28,456,789 bytes  \n    └── org.apache.http.impl.client.CloseableHttpClient  12,345  18,567,890 bytes\n\n[GC Root 분석]\nThread \"http-nio-8080-exec-1\"\n└── Static Variable: SessionManager.activeSessions\n    └── ConcurrentHashMap\n\n① PreparedStatement 객체들이 close()되지 않아 누적되고 있다.\n② HTTP 커넥션이 정상적으로 해제되지 않아 메모리 누수가 발생했다.\n③ 사용자 세션이 만료되어도 SessionManager에서 제거되지 않고 있다.\n④ ConcurrentHashMap의 내부 배열이 동적으로 확장되면서 메모리를 과도하게 사용하고 있다.\n⑤ 스레드 풀의 스레드들이 종료되지 않아 메모리가 해제되지 않고 있다.",
    "answer": "③",
    "explanation": "Static Variable로 참조되는 SessionManager.activeSessions에서 45,678개의 UserSession이 제거되지 않고 있어 메모리 누수가 발생하고 있다.",
    "keywords": [
      "JVM",
      "OutOfMemory",
      "Heap Dump",
      "Memory Leak"
    ]
  },
  {
    "id": "q3-1",
    "number": "3-1",
    "module": "Software Architecture 설계/구축",
    "subModule": "분산 시스템 패턴",
    "title": "Transactional Outbox Pattern",
    "difficulty": "상급",
    "points": 5,
    "question": "[CK사 Transactional Outbox Pattern 기반 온라인/배치 Kafka 메시지 처리 흐름]\n\n다음은 현재 시스템의 처리 흐름입니다:\n1. 온라인과 배치 프로그램에서 비즈니스 로직에 따라 DB의 업무 데이터 CUD 수행\n2. Kafka 전송용 메시지, 대상 Topic 정보 등을 Outbox Table에 Insert 수행 (1번과 2번을 하나의 트랜잭션으로 처리)\n3. CDC 프로그램이 Outbox 테이블을 주기적으로 조회\n4. Kafka에 메시지를 Publish\n5. Kafka에 Publish된 메시지의 전송 여부 Flag 컬럼 Update\n6. 온라인 서비스 B에서 메시지 Subscribe 후 Biz Logic 처리\n\n온라인 서비스 A의 Kafka 메시지 처리 지연이 발생하고 있습니다. \n지연의 주요 원인으로 가장 가능성이 높은 것은?\n\n① CUD + Outbox Insert 트랜잭션 처리 시간이 길어짐\n② 배치 프로그램의 대량 메시지로 인한 Outbox 테이블 처리 지연\n③ Kafka 브로커의 처리 용량 부족\n④ 서비스 B의 메시지 처리 속도 저하\n⑤ CDC 프로그램의 메모리 부족",
    "answer": "②",
    "explanation": "배치 프로그램이 대량 메시지를 Outbox 테이블에 Insert하면 CDC Polling 방식으로는 한정된 범위 내에서만 메시지 조회 및 처리가 가능하여 온라인 서비스 A의 메시지가 뒤로 밀리게 된다.",
    "keywords": [
      "Transactional Outbox",
      "Kafka",
      "CDC",
      "분산 시스템"
    ]
  },
  {
    "id": "q6-1",
    "number": "6-1",
    "module": "Software Architecture 핵심",
    "subModule": "Backing Service",
    "title": "Kafka 클러스터 주문 처리",
    "difficulty": "상급",
    "points": 4,
    "question": "Kafka 클러스터에서 주문 처리 시스템을 구축할 때, 고객별 주문 순서를 보장해야 한다. 다음 중 올바른 설계 방안은?\n\n① 모든 주문을 단일 파티션으로 처리하여 전체 순서를 보장한다\n② 주문 ID를 파티션 키로 사용하여 분산 처리한다\n③ 고객 ID를 파티션 키로 사용하여 고객별 순서를 보장한다\n④ Round-robin 방식으로 파티션을 할당하여 부하를 분산한다\n⑤ 타임스탬프를 파티션 키로 사용하여 시간 순서를 보장한다",
    "answer": "③",
    "explanation": "고객 ID를 파티션 키로 사용하면 동일 고객의 모든 주문이 같은 파티션으로 가므로 고객별 순서가 보장되며, 여러 파티션을 활용해 확장성도 확보할 수 있다.",
    "keywords": [
      "Kafka",
      "Partition",
      "Message Ordering",
      "분산 처리"
    ]
  }
]